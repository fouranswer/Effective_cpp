# Item 14_자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자

## 세상의 모든 자원이 힙에서 생기지는 않는다. 

힙에 생기지 않는 자원은 auto_ptr과 tr1::shared_ptr의 스마트 포인터로 처리하기에는 맞지 않다(고 한다)

자원 관리 클래스를 직접 만들어야할 필요가 있습니다. 

### Mutex 예제

```c++
void lock(Mutex *pm);    // pm이 가리키는 mutex에 잠금을 겁니다.
void unlock(Mutex *pm);    // pm이 가리키는 mutex에 잠금을 풉니다.
```

Mutex 잠금을 관리하는 클래스를 만들어서, 이전에 lock을 걸어놧던 것을 잊지않고 풀어주는 목적!

RAII 법칙에 따라 생성시 자원 획득, 소멸시 자원 해제

```c++

class Lock {
    public:
    explicit Lock(Mutex *pm): mutexPtr(pm)
    { lock(mutexPtr); }    // 자원을 획득

    ~Lock() { unlock(mutexPtr); }   //자원 해제

    private:
      Mutex *mutexPtr;
};

Mutex m;            // mutex 정의
...

{                   // 임계 영역(critical section)을 정하기 위해 블록 생성
    Lock m1(&m);    // 잠금 걸기
    ...             // 임계 영역에서 할 연산 수행
}                   // 일 끝났고, mutex 잠금이 자동 해제
```

### Lock 객체가 복사되면 어떻게 해야할까요?

```c++
Lock m11(&m);    // m에 잠금 걸기
Lock m12(m11);   // m11을 m12로 복사. 어떻게 되야 맞을까?
```

#### 1. 복사를 금지합니다. 

RAII 객체를 복사가 되지 않도록 막아야합니다. 복사 막는 방법(ITEM 6 참고)
복사 연산(함수)를 private로 만드는 것이다!

```c++
class Lock: private Uncopyable {    // 복사 금지하기 (ITEM 6 참고)
    public:
    ...
};
```

#### 2. 관리하고 있는 자원에 대해 참조 카운팅을 수행합니다. 

해당 자원을 참조하는 객체의 개수에 대한 카운트를 증가시키는 식으로 복사 동작을 만들어야합니다. 
실제 tr1::shared_ptr이 그렇게 사용됩니다. 

다만 tr1::shared_ptr을 사용하면 참조카운트가 0이 되버리면 객체를 삭제합니다. 
우리는 mutex로 잠금 해제만 하면 되는데...

tr1::shared_ptr는 다행이도, deleter 지정을 허용합니다. (2번째 파라메터를 통해서)

```c++
class Lock {
    public:
    explicit Lock(Mutex *pm): mutexPtr(pm, unlock)    // 삭제자(deleter)로 unlock 함수 선택
    { 
        lock(mutexPtr.get());    // 자원을 획득 . get의 경우 ITEM 15 참조
    }    
    private:
      std::tr1::shared_ptr<Mutex> mutexPtr;   // 원시 포인터 대신 shared_ptr을 사용합니다.
};
```

이 코드에서는 소멸자가 없어요. 자동으로 소멸자 호출됩니다. 
"객체 소멸 과정을 잊은게 아니라 컴파일러가 생성한 소멸자를 통해 동작한다"

말이 좀 헷갈리지만...

'비정적 데이터 멤버' mutexPtr의 소멸자를 부를 것이다. mutex의 참조 카운트가 0이 되었는가?
tr1::shared_ptr 의 삭제자(deleter)께서 호출되신다! (그 이름은 unlock이다)


#### 3. 관리하고 있는 자원을 진짜로 복사합니다. 

자원 관리 객체를 복사하면 그 객체가 둘러싸고 있는 자원까지 복사되어야합니다. (deep copy)
표준 string 타입으로 생성한 객체는 힙 메모리를 포인터로 가리키는 형태가 됩니다. 

이 객체를 복사하면 사본은 포인터 및 그 포인터가 가리키는(새로운) 힙 메모리를 가지게 됩니다. (deep copy)


#### 4. 관리하고 있는 자원의 소유권을 옮깁니다. 

어떤 경우에는 RAII 객체를 딱 하나만 존재하도록 하고 싶어합니다. 
RAII 객체 복사시 자원의 소유권을 사본 쪽으로 아예 옮겨야할 경우도 생깁니다. 

이럴 경우 auto_ptr의 '복사' 동작을 사용합니다. 

----------
객체 복사 함수(복사 생성자 및 복사 대입 연산자)는 컴파일러에 의해 생성될 여지가 있기 때문에 컴파일러가 생성한 동작이 원하는 바와 맞지 않으면 직접 만들 수 밖에 없습니다. 

# 이것만은 잊지말자!
1. RAII 객체의 복사는 그 객체가 관리하는 자원의 복사 문제를 안고 가기 때문에, 그 자원을 어떻게 복사해주느냐에 따라 RAII 객체의 복사 동작이 결정됩니다. 

2. RAII 클래스에 구현하는 일반적인 복사 동작은 복사를 금지하거나 참조 카운팅을 해 주는 선으로 마무리하는 것입니다. 하지만 이 외의 방법들도 가능하니 참고해 둡시다. 


