# Item.1: C++를 언어들의 연합체로 바라보는 안목은 필수 

행동방식과 사고방식을 C++ 스타일로 만들 필요가 있습니다.
근본적인 것들을 다루고 있는 것이 1장입니다. 

초창기의 C++은 "클래스를 쓰는 C(C with Classes)" 였다. 

예외 : 함수 구성방식을 헤게모니를 바꿈
템플릿 : 설계에 대한 새로운 사고방식
STL : 누구도 본적이 없는 '확장성'에 대한 지평을 열음

오늘날의 C++은 다중 패러다임 프로그래밍 언어(multiparadigm programming language)라고 함

절차적(procedural) 프로그래밍을 기본으로 하여, 객체지향(object-oriented), 함수식(functional), 일반화(generic), 메타(meta) 프로그래밍 개념까지 지원함
너무 많은 것들이 있다. 어떻게 이해해야 잘한다고 소문이 날까?

## 여러 연합들의 연합체(federation)
여러개의 하위 언어(sublanguage)를 제공한다고 생각하자. 

### C
C++은 여전히 C를 기본으로 한다. 모든 것들은 C에서 왔다. 
C++에서도 C는 동작된다. 다만, 템플릿, 예외, 오버로딩이 전혀 없다.. 등등

### 객체 지향의 C++
Class!!, 생성자, 소멸자, 캡슐화, 상속, 다형성, 가상함수(동적바인딩)


### Template C++
Template은 주체못할 정도로 강력하고 훌륭하다. 템플릿은 C++에 가히 전방위적인 영향력이 끼친다. 
결국 템플릿 메타프로그래밍(Template metaprogramming: TMP)이 나온다. 

### STL
STL(Standard Template Library)
Container, Iterator, Algoritm, Function object...
STL을 사용하려면 독특한 사용규칙이 있다.


## 당황하지말자
효과적인 프로그램개발을 위해 한 하위언에서 다른 하위언어로 옮겨가면서 대응 전략을 바꾸어야한다

c에서는 "값 전달이 참조전달보다 대개 효율이 좋다" 라는 규칙이 통하지만
Template c++로 옮겨가면 생성자/소멸자 개념이 생기면서 상수 객체 참조자(pass-by-reference-to-const)에 의한 전달 방식이 더 좋은 효율을 보인다.
(객체의 타입을 알 수 없기 때문이야!)

STL에서는 C의 포인터를 참고하여 만든 것이기 때문에 값전달이 좀 더 효율 좋게 바뀌게된다. 

## 다시 말하지만... C++은 통합 언어가 아니라 4가지 하위언어로 뭉친 연합체이다.


# 이것만은 잊지말자
* C++의 어느 부분을 사용하느냐에 따라서 효과적인 프로그래밍 규칙이 달라진다. 
